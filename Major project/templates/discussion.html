<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Group Discussion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      background-color: #001f3f;
      color: white;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      zoom: 1;
    }
    .header {
      position: sticky;
      top: 0;
      z-index: 1000;
      background-color: #002244;
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: flex-start;
      align-items: center;
    }
    .menu-toggle {
      width: 2.5rem;
      height: 2.5rem;
      background: none;
      border: none;
      cursor: pointer;
      position: relative;
      padding: 0;
    }
    .menu-toggle span {
      width: 100%;
      height: 0.3rem;
      background-color: #00ffcc;
      position: absolute;
      transition: all 0.3s;
    }
    .menu-toggle span:nth-child(1) { top: 0.5rem; }
    .menu-toggle span:nth-child(2) { top: 1.2rem; }
    .menu-toggle span:nth-child(3) { top: 1.9rem; }
    .menu-toggle.active span:nth-child(1) {
      transform: rotate(45deg) translate(0.5rem, 0.5rem);
    }
    .menu-toggle.active span:nth-child(2) {
      opacity: 0;
    }
    .menu-toggle.active span:nth-child(3) {
      transform: rotate(-45deg) translate(0.5rem, -0.5rem);
    }
    .menu-dropdown {
      display: none;
      position: absolute;
      top: 3rem;
      left: 0;
      background-color: #002244;
      border-radius: 0.5rem;
      box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.3);
      min-width: 8rem;
    }
    .menu-dropdown.active {
      display: block;
    }
    .menu-dropdown button {
      width: 100%;
      padding: 0.5rem 1rem;
      border: none;
      background: none;
      color: #00ffcc;
      font-size: 1.2rem;
      cursor: pointer;
      text-align: left;
      transition: background-color 0.3s;
    }
    .menu-dropdown button:hover {
      background-color: #003366;
    }
    .container {
      display: flex;
      width: 100%;
      max-width: 90vw;
      height: calc(100vh - 4rem);
      margin: 0 auto;
      gap: 1rem;
      margin-top: 0;
    }
    .left-panel {
      width: 25%;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      background-color: #002244;
      border-radius: 1rem;
      overflow-y: auto;
    }
    .right-panel {
      width: 75%;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      background: linear-gradient(135deg, #003366, #005577);
      border: 0.3rem solid #00ffcc;
      border-radius: 1rem;
      box-shadow: 0 0 1.5rem #00ffcc;
      position: relative;
    }
    .info-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background-color: rgba(0, 34, 68, 0.8);
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      z-index: 10;
    }
    #timer, #score {
      font-size: 1.3rem;
      color: #00ffcc;
      text-shadow: 0 0 0.3rem #00ffcc;
    }
    #score { color: #ffcc00; text-shadow: 0 0 0.3rem #ffcc00; }
    #handRaiseCountdown {
      font-size: 1.2rem;
      color: #ff4444;
      display: none;
    }
    .chat-area {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }
    h1 {
      font-size: 2.5rem;
      text-align: center;
      margin: 1rem 0;
      text-shadow: 0 0 0.5rem #00ffcc;
    }
    .participant {
      text-align: center;
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background-color: rgba(255, 255, 255, 0.1);
      transition: background-color 0.3s;
    }
    .participant:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    .participant img {
      width: 6rem;
      height: 6rem;
      margin-bottom: 0.5rem;
      border-radius: 50%;
      transition: transform 0.3s;
      position: relative;
    }
    .participant.processing img {
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(0, 255, 204, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(0, 255, 204, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 255, 204, 0); }
    }
    .participant img:hover {
      transform: scale(1.1);
    }
    .user-speaking img {
      border: 0.3rem solid #28a745;
    }
    .glow {
      box-shadow: 0 0 1rem 0.5rem #00ffcc;
      border-radius: 50%;
    }
    .label {
      font-size: 1.5rem;
      font-weight: bold;
      color: #00ffcc;
    }
    .action-buttons button {
      font-size: 1.2rem;
      padding: 0.5rem 1rem;
      margin: 0.5rem;
      border-radius: 0.5rem;
      border: none;
      background-color: #007BFF;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }
    .action-buttons button:hover {
      background-color: #0056b3;
      transform: scale(1.05);
    }
    .action-buttons button:disabled {
      background-color: #666;
      cursor: not-allowed;
      transform: none;
    }
    #userInput {
      width: 100%;
      font-size: 1.3rem;
      padding: 0.5rem;
      border-radius: 0.5rem;
      border: 0.2rem solid #333;
      margin-top: 1rem;
      background-color: #fff;
    }
    .message {
      display: flex;
      flex-direction: column;
      margin: 0.5rem 0;
      max-width: 70%;
    }
    .message .sender {
      font-size: 0.9rem;
      color: #00ffcc;
      margin-bottom: 0.2rem;
    }
    .message .content {
      padding: 0.8rem;
      border-radius: 0.8rem;
      box-shadow: 0 0.2rem 0.5rem rgba(0, 0, 0, 0.3);
      word-wrap: break-word;
    }
    .user-msg .content {
      background-color: #d9fdd3;
      color: black;
      margin-left: auto;
      border-radius: 0.8rem 0.8rem 0 0.8rem;
    }
    .bot-msg .content {
      background-color: #f1f0f0;
      color: black;
      margin-right: auto;
      border-radius: 0.8rem 0.8rem 0.8rem 0;
    }
    .bot-2 .content { background-color: #e6f3ff; }
    .bot-3 .content { background-color: #ffe6e6; }
    .bot-4 .content { background-color: #e6ffe6; }
    .system-msg .content {
      background-color: #ff9900;
      color: white;
      text-align: center;
      margin: 0 auto;
      border-radius: 0.8rem;
    }
    .message:hover .content {
      transform: translateY(-0.2rem);
      transition: transform 0.2s;
    }
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
        height: auto;
      }
      .left-panel, .right-panel {
        width: 100%;
      }
      h1 {
        font-size: 2rem;
      }
      .participant img {
        width: 4rem;
        height: 4rem;
      }
      .label {
        font-size: 1.2rem;
      }
      .action-buttons button {
        font-size: 1rem;
      }
      .menu-toggle {
        width: 2rem;
        height: 2rem;
      }
      .menu-toggle span {
        height: 0.25rem;
      }
      .menu-toggle span:nth-child(1) { top: 0.4rem; }
      .menu-toggle span:nth-child(2) { top: 1rem; }
      .menu-toggle span:nth-child(3) { top: 1.6rem; }
      .menu-dropdown {
        top: 2.5rem;
      }
      .message .content {
        font-size: 1.1rem;
      }
      #userInput, #timer, #score, #handRaiseCountdown {
        font-size: 1.1rem;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <button class="menu-toggle" onclick="this.classList.toggle('active'); document.querySelector('.menu-dropdown').classList.toggle('active');">
      <span></span><span></span><span></span>
    </button>
    <div class="menu-dropdown">
      <button class="start-btn" onclick="startDiscussion()">Start</button>
      <button class="pause-btn" onclick="togglePause()">Pause</button>
      <button class="end-btn" onclick="endDiscussion()">End</button>
    </div>
  </div>
  <h1>AI Group Discussion: {{ topic }}</h1>
  <div class="container">
    <div class="left-panel">
      {% for i in range(participants|length) %}
        <div class="participant" id="participant-{{ i }}">
          <img src="/static/robot-idle.png" id="img-{{ i }}" alt="{{ participants[i] }}">
          <div class="label">{{ participants[i] }}</div>
          {% if i == 0 %}
            <div class="action-buttons">
              <button id="raiseHandBtn" onclick="raiseHand(0)">âœ‹ Raise Hand</button>
              <button id="micBtn" onclick="startRecording(0)" disabled>ðŸŽ™ Mic</button>
            </div>
          {% endif %}
        </div>
      {% endfor %}
    </div>
    <div class="right-panel">
      <div class="info-bar">
        <div id="timer">Discussion Time: 00:00</div>
        <div id="score">Your Score: 0</div>
        <div id="handRaiseCountdown">Hand Raise Timeout: 10s</div>
      </div>
      <div class="chat-area" id="discussionArea"></div>
      <input type="text" id="userInput" placeholder="Type your message here..." onkeypress="if(event.key === 'Enter') sendTextMessage(0)" disabled>
    </div>
  </div>
  <script>
    let discussionStarted = false;
    let lastBotResponseTime = 0;
    let isPaused = false;
    let startTime = null;
    let pausedTime = 0;
    let handRaised = false;
    let handRaiseTimeout = null;
    let handRaiseCountdownInterval = null;
    const topic = "{{ topic }}";
    const participants = {{ participants | tojson }};
    const userActivity = Array(participants.length).fill(null);
    let isSpeaking = false;
    let userScore = 0;
    let currentSpeaker = null;
    let previousResponses = new Set();
    let lastAddressed = new Map();
    let currentUserMessage = '';
    let lastProcessedMessage = '';
    let currentUtterance = null;
    let botQueue = [];
    let waitingForCurrentBotToFinish = false;
    let botProcessingPaused = false;
    function startDiscussion() {
      if (discussionStarted) return;
      console.log("Starting discussion...");
      sessionStorage.setItem('gdStartTime', Date.now());
      discussionStarted = true;
      isPaused = false;
      startTime = Date.now();
      pausedTime = 0;
      document.querySelector('.menu-dropdown .pause-btn').textContent = 'Pause';
      document.getElementById('userInput').disabled = false;
      addMessage('system', 'System', `Discussion started on topic: <strong>${topic}</strong>. Please speak to begin.`);
      autoScroll();
      updateTimer();
      document.querySelector('.menu-toggle').classList.remove('active');
      document.querySelector('.menu-dropdown').classList.remove('active');
    }
    function togglePause() {
      if (!discussionStarted) return;
      isPaused = !isPaused;
      document.querySelector('.menu-dropdown .pause-btn').textContent = isPaused ? 'Resume' : 'Pause';
      
      if (isPaused) {
        pausedTime += Date.now() - startTime;
        botProcessingPaused = true;
        
        if (currentUtterance) {
          speechSynthesis.cancel();
          currentUtterance = null;
        }
        
        if (currentSpeaker !== null) {
          const img = document.getElementById(`img-${currentSpeaker}`);
          img.src = "/static/robot-idle.png";
          img.classList.remove("glow");
          currentSpeaker = null;
        }
        
        const userImg = document.getElementById('img-0');
        userImg.classList.remove("user-speaking");
        
        // Disable user interactions
        document.getElementById('raiseHandBtn').disabled = true;
        document.getElementById('micBtn').disabled = true;
        document.getElementById('userInput').disabled = true;
        
      } else {
        startTime = Date.now() - pausedTime;
        botProcessingPaused = false;
        updateTimer();
        
        // Re-enable user interactions
        document.getElementById('raiseHandBtn').disabled = false;
        if (handRaised) {
          document.getElementById('micBtn').disabled = false;
        }
        document.getElementById('userInput').disabled = false;
        
        // Resume bot processing if needed
        if (botQueue.length > 0) {
          processBotQueue('[Discussion resumed]');
        } else {
          triggerBotResponses('[Discussion resumed]');
        }
      }
    }
    function endDiscussion() {
      clearTimeout(handRaiseTimeout);
      clearInterval(handRaiseCountdownInterval);
      discussionStarted = false;
      isPaused = false;
      handRaised = false;
      isSpeaking = false;

      if (currentUtterance) {
        speechSynthesis.cancel();
        currentUtterance = null;
      }

      if (currentSpeaker !== null) {
        const img = document.getElementById(`img-${currentSpeaker}`);
        img.src = "/static/robot-idle.png";
        img.classList.remove("glow");
        currentSpeaker = null;
      }

      const userImg = document.getElementById('img-0');
      userImg.src = "/static/robot-idle.png";
      userImg.classList.remove("user-speaking");

      // Store the user score in sessionStorage
      sessionStorage.setItem('userScore', userScore);

      window.location.href = "/results";
    }

    function updateTimer() {
      if (!discussionStarted || isPaused) return;
      const elapsed = Math.floor((Date.now() - startTime - pausedTime) / 1000);
      const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const seconds = String(elapsed % 60).padStart(2, '0');
      document.getElementById('timer').textContent = `Discussion Time: ${minutes}:${seconds}`;
      if (elapsed >= 600) { // 10 minutes
        endDiscussion();
      } else {
        setTimeout(updateTimer, 1000);
      }
    }
    function updateScore(points) {
      userScore += points;
      document.getElementById('score').textContent = `Your Score: ${userScore.toFixed(1)}`;
      console.log(`Updated score: ${userScore}`);
    }

    function raiseHand(index) {
      if (!discussionStarted || isPaused || index !== 0 || handRaised || isSpeaking) return;

      console.log("User raised hand - pausing bot processing");
      handRaised = true;
      waitingForCurrentBotToFinish = true;
      botProcessingPaused = true;

      // Clear any existing timeouts
      clearTimeout(handRaiseTimeout);
      clearInterval(handRaiseCountdownInterval);

      // Immediately stop any ongoing speech synthesis
      if (currentUtterance) {
        speechSynthesis.cancel();
        currentUtterance = null;
      }

      addMessage('system', 'System', `${participants[index]} raised their hand. Bots are waiting.`);
      autoScroll();

      // Disable raise hand button and enable mic
      document.getElementById('raiseHandBtn').disabled = true;
      document.getElementById('micBtn').disabled = false;

      // Start the hand raise timeout immediately
      finishHandRaiseSetup();
    }

    function finishHandRaiseSetup() {
      console.log("Setting up hand raise timeout");
      waitingForCurrentBotToFinish = false;

      // Stop any ongoing bot processing
      if (currentSpeaker !== null && currentSpeaker !== 0) {
        const img = document.getElementById(`img-${currentSpeaker}`);
        img.src = "/static/robot-idle.png";
        img.classList.remove("glow");
      }

      // Clear bot queue
      botQueue = [];
      currentSpeaker = null;

      document.getElementById('handRaiseCountdown').style.display = 'block';
      let countdown = 10;
      document.getElementById('handRaiseCountdown').textContent = `Hand Raise Timeout: ${countdown}s`;

      handRaiseCountdownInterval = setInterval(() => {
        countdown--;
        document.getElementById('handRaiseCountdown').textContent = `Hand Raise Timeout: ${countdown}s`;
        if (countdown <= 0) {
          clearInterval(handRaiseCountdownInterval);
          document.getElementById('handRaiseCountdown').style.display = 'none';
          resetHandRaiseState();
          addMessage('system', 'System', 'Timeout. Bots will talk now.');
          triggerBotResponses(`[${participants[0]} raised hand but was quiet]`);
        }
      }, 1000);

      handRaiseTimeout = setTimeout(() => {
        if (handRaised) {
          resetHandRaiseState();
          addMessage('system', 'System', 'Timeout. Bots will talk now.');
          triggerBotResponses(`[${participants[0]} raised hand but was quiet]`);
        }
      }, 10000);
    }

    function resetHandRaiseState() {
      handRaised = false;
      waitingForCurrentBotToFinish = false;
      botProcessingPaused = false;
      
      clearTimeout(handRaiseTimeout);
      clearInterval(handRaiseCountdownInterval);
      document.getElementById('handRaiseCountdown').style.display = 'none';
      
      // Reset button states
      document.getElementById('raiseHandBtn').disabled = false;
      document.getElementById('micBtn').disabled = true;
    }
    function startRecording(userIndex) {
      if (!discussionStarted || isPaused || userIndex !== 0 || isSpeaking || !handRaised) return;
      
      console.log("Starting recording...");
      
      // Clear hand raise timeout since user is now speaking
      clearTimeout(handRaiseTimeout);
      clearInterval(handRaiseCountdownInterval);
      document.getElementById('handRaiseCountdown').style.display = 'none';
      
      isSpeaking = true;
      const img = document.getElementById('img-0');
      img.src = "/static/robot-talking.gif";
      img.classList.add("user-speaking");
      
      // Disable mic button while speaking
      document.getElementById('micBtn').disabled = true;
      
      currentUserMessage = '';
      let lastDisplayedMessage = '';
      
      if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
        console.error('Speech not supported.');
        addMessage('system', 'System', 'Speech not supported. Use Chrome or a compatible browser.');
        resetAfterSpeaking();
        return;
      }
      
      const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = 'en-IN';
      recognition.interimResults = true; // Enable interim results for real-time display
      recognition.continuous = false;
      recognition.maxAlternatives = 1;
      
      let tempMessageDiv = null; // For showing interim results
      
      recognition.onstart = () => {
        console.log("Recognition started successfully");
      };
      
      recognition.onspeechstart = () => {
        console.log("Speech detected");
      };
      
      recognition.onresult = function(event) {
        let interimTranscript = '';
        let finalTranscript = '';
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + ' ';
          } else {
            interimTranscript += transcript;
          }
        }
        
        // Show interim results in real-time
        if (interimTranscript) {
          if (!tempMessageDiv) {
            tempMessageDiv = addTemporaryMessage('user', participants[0], interimTranscript);
          } else {
            tempMessageDiv.querySelector('.content').textContent = interimTranscript;
          }
          autoScroll();
        }
        
        // Handle final results
        if (finalTranscript) {
          const displayMessage = finalTranscript.trim();
          if (displayMessage && displayMessage !== lastDisplayedMessage && displayMessage !== lastProcessedMessage) {
            lastDisplayedMessage = displayMessage;
            currentUserMessage = displayMessage;
            
            // Remove temporary message and add final one
            if (tempMessageDiv) {
              tempMessageDiv.remove();
              tempMessageDiv = null;
            }
            
            addMessage('user', participants[0], displayMessage);
            autoScroll();
          }
        }
      };
      
      recognition.onspeechend = () => {
        console.log("Speech ended");
        recognition.stop();
      };
      
      recognition.onend = function() {
        console.log("Recognition ended");
        
        // Remove temporary message if it exists
        if (tempMessageDiv) {
          tempMessageDiv.remove();
          tempMessageDiv = null;
        }
        
        resetAfterSpeaking();
        
        if (currentUserMessage.trim() && currentUserMessage.trim() !== lastProcessedMessage) {
          lastProcessedMessage = currentUserMessage.trim();
          const endTime = Date.now();
          const startTime = sessionStorage.getItem('gdStartTime');
          userActivity[0] = endTime;
          
          fetch('/record-timestamp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              user_index: 0,
              start: parseFloat(startTime),
              end: endTime
            })
          }).then(() => {
            updateScore(1.0);
          }).catch(err => console.error("Timestamp error:", err));
          
          triggerBotResponses(currentUserMessage.trim());
        }
      };
      
      recognition.onerror = function(event) {
        console.log("Recognition error:", event.error);
        if (tempMessageDiv) {
          tempMessageDiv.remove();
          tempMessageDiv = null;
        }
        resetAfterSpeaking();
        addMessage('system', 'System', `Error: ${event.error}. Check microphone permissions or try again.`);
        autoScroll();
      };
      
      try {
        recognition.start();
        console.log("Attempted to start recognition");
      } catch (e) {
        console.error("Failed to start recognition:", e);
        resetAfterSpeaking();
        addMessage('system', 'System', 'Failed to start microphone. Check browser settings or permissions.');
        autoScroll();
      }
    }
    function resetAfterSpeaking() {
      isSpeaking = false;
      const img = document.getElementById('img-0');
      img.src = "/static/robot-idle.png";
      img.classList.remove("user-speaking");
      
      // Reset hand raise state
      resetHandRaiseState();
    }
    function sendTextMessage(userIndex) {
      const inputBox = document.getElementById('userInput');
      const userText = inputBox.value.trim();
      
      if (userText && !isPaused && discussionStarted) {
        const endTime = Date.now();
        const startTime = sessionStorage.getItem('gdStartTime');
        userActivity[0] = endTime;
        
        fetch('/record-timestamp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_index: 0,
            start: parseFloat(startTime),
            end: endTime
          })
        }).then(() => {
          updateScore(1.0);
        }).catch(err => console.error("Timestamp error:", err));
        
        addMessage('user', participants[0], userText);
        autoScroll();
        triggerBotResponses(userText);
        inputBox.value = '';
      }
    }
    function addTemporaryMessage(type, sender, content) {
      const discussionArea = document.getElementById('discussionArea');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}-msg`;
      messageDiv.style.opacity = '0.7'; // Make it slightly transparent to indicate it's temporary
      messageDiv.innerHTML = `
        <div class="sender">${sender} (speaking...)</div>
        <div class="content">${content}</div>
      `;
      discussionArea.appendChild(messageDiv);
      return messageDiv;
    }
    async function triggerBotResponses(userText) {
    if (!userText || userText.trim() === '' || isPaused || botProcessingPaused || waitingForCurrentBotToFinish) return;
    // Shuffle bot order for more natural conversation
    const availableBots = Array.from({ length: participants.length - 1 }, (_, i) => i + 1);
    botQueue = shuffleArray(availableBots);
    console.log("Triggering bot responses for:", userText);
    await processBotQueue(userText);
  }
  // Add this helper function after the triggerBotResponses function
  function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
    async function processBotQueue(userText) {
      while (botQueue.length > 0 && discussionStarted && !isPaused && !botProcessingPaused && !waitingForCurrentBotToFinish) {
        const botIndex = botQueue.shift();
        const participantDiv = document.getElementById(`participant-${botIndex}`);
        participantDiv.classList.add('processing');
        console.log(`Processing bot ${participants[botIndex]}`);
        await getBotResponse(userText, botIndex);
        participantDiv.classList.remove('processing');
        // Check if user raised hand during bot processing
        if (handRaised || botProcessingPaused || waitingForCurrentBotToFinish) {
          console.log("Bot processing interrupted - user raised hand");
          break;
        }
        // Wait between bot responses
        await new Promise(resolve => setTimeout(resolve, 2000));
        // If queue is empty but discussion should continue, refill with random bots
        if (botQueue.length === 0 && discussionStarted && !isPaused && !botProcessingPaused && !handRaised) {
          // Add random delay before continuing (3-6 seconds)
          const delay = Math.random() * 3000 + 3000;
          await new Promise(resolve => setTimeout(resolve, delay));
          // Check again if we should continue
          if (discussionStarted && !isPaused && !botProcessingPaused && !handRaised) {
            // Select 2-3 random bots to continue discussion
            const availableBots = Array.from({ length: participants.length - 1 }, (_, i) => i + 1);
            const numBots = Math.floor(Math.random() * 2) + 2; // 2-3 bots
            botQueue = shuffleArray(availableBots).slice(0, numBots);
            console.log("Continuing discussion with bots:", botQueue.map(i => participants[i]));
          }
        }
      }
    }
    async function getBotResponse(userText, botIndex) {
      if (botProcessingPaused || waitingForCurrentBotToFinish) return;

      // Prevent rapid-fire responses
      const now = Date.now();
      if (now - lastBotResponseTime < 1000) {
        await new Promise(resolve => setTimeout(resolve, 1000 - (now - lastBotResponseTime)));
      }
      lastBotResponseTime = Date.now();

      currentSpeaker = botIndex;
      const img = document.getElementById(`img-${botIndex}`);
      // Reset other bot images immediately
      for (let i = 1; i < participants.length; i++) {
        if (i !== botIndex) {
          const otherImg = document.getElementById(`img-${i}`);
          otherImg.src = "/static/robot-idle.png";
          otherImg.classList.remove("glow");
        }
      }

      let response = 'No reply from bot.';
      console.log(`Bot ${participants[botIndex]} responding to: "${userText}"`);

      try {
        const action = ['support', 'oppose', 'counter'][Math.floor(Math.random() * 3)];
        const prompt = `Topic: ${topic}. You are ${participants[botIndex]}. Someone said: "${userText}". Give a short reply (2-3 lines, 20-30 words) in simple English ${action}ing them. Use examples and talk to someone.`;

        const fetchResponse = await fetch('/bot-reply', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt })
        });

        if (fetchResponse.ok) {
          const data = await fetchResponse.json();
          response = data.reply || 'No reply from bot.';
        } else {
          console.error(`API error for ${participants[botIndex]}:`, fetchResponse.status);
          response = `${participants[botIndex]} says: Sorry, server issue. I'll try later.`;
        }
      } catch (err) {
        console.error(`Error for ${participants[botIndex]}:`, err);
        response = `${participants[botIndex]} says: Sorry, I can't reply now. Try again.`;
      }

      if (!response || response.trim() === 'No reply from bot.') {
        response = `${participants[botIndex]} says: Sorry, I need time. I will reply later.`;
      } else if (previousResponses.has(response)) {
        response = `${participants[botIndex]} says: New idea! ${topic} is good. Like reading daily.`;
      } else {
        const lastAddr = lastAddressed.get(botIndex) || -1;
        let newAddr = -1;
        const validAddresses = Array.from({ length: participants.length }, (_, i) => i);
        do {
          newAddr = validAddresses[Math.floor(Math.random() * validAddresses.length)];
        } while (newAddr === botIndex || newAddr === lastAddr);
        lastAddressed.set(botIndex, newAddr);
        response = response.replace(/Address (.*?) /, `Address ${participants[newAddr]} `) || response;
        previousResponses.add(response);
      }

      // Clean the response to remove special characters
      response = response.replace(/\*/g, '').replace(/\[|\]/g, '');

      const voices = speechSynthesis.getVoices();
      let selectedVoice;
      if (botIndex === 1 || botIndex === 3) { // Female bots (1, 3)
        selectedVoice = voices.find(v => v.name.toLowerCase().includes('female') && v.lang.includes('en-IN') && !v.name.toLowerCase().includes('us')) ||
                      voices.find(v => v.name.toLowerCase().includes('female') && v.lang.includes('en-IN')) ||
                      voices.find(v => v.name.toLowerCase().includes('female'));
      } else if (botIndex === 2 || botIndex === 4) { // Male bots (2, 4)
        selectedVoice = voices.find(v => v.name.toLowerCase().includes('male') && v.lang.includes('en-IN') && !v.name.toLowerCase().includes('us')) ||
                      voices.find(v => v.name.toLowerCase().includes('male') && v.lang.includes('en-IN')) ||
                      voices.find(v => v.name.toLowerCase().includes('male'));
      }

      const utterance = new SpeechSynthesisUtterance(response);
      utterance.lang = 'en-IN';
      utterance.volume = 1.0;
      utterance.rate = 0.9;
      utterance.pitch = 1.0;
      if (selectedVoice) utterance.voice = selectedVoice;
      currentUtterance = utterance;

      // Check if hand is raised before speaking
      if (handRaised) {
        img.src = "/static/robot-idle.png";
        img.classList.remove("glow");
        currentSpeaker = null;
        currentUtterance = null;
        return;
      }

      // Add event handlers BEFORE speaking
      utterance.onstart = () => {
        img.src = "/static/robot-talking.gif";
        img.classList.add("glow");
        addMessage('bot', participants[botIndex], response);
        autoScroll();
        if (handRaised) {
          waitingForCurrentBotToFinish = true;
        }
      };

      utterance.onend = () => {
        currentUtterance = null;
        img.src = "/static/robot-idle.png";
        img.classList.remove("glow");
        currentSpeaker = null;
        waitingForCurrentBotToFinish = false;
        if (handRaised) {
          botProcessingPaused = true;
          return;
        }
      };

      utterance.onerror = () => {
        currentUtterance = null;
        img.src = "/static/robot-idle.png";
        img.classList.remove("glow");
        currentSpeaker = null;
        waitingForCurrentBotToFinish = false;
      };

      speechSynthesis.speak(utterance);
    }
    function endDiscussion() {
      clearTimeout(handRaiseTimeout);
      clearInterval(handRaiseCountdownInterval);
      discussionStarted = false;
      isPaused = false;
      handRaised = false;
      isSpeaking = false;
      botProcessingPaused = false;
      waitingForCurrentBotToFinish = false;
      if (currentUtterance) {
        speechSynthesis.cancel();
        currentUtterance = null;
      }
      if (currentSpeaker !== null) {
        const img = document.getElementById(`img-${currentSpeaker}`);
        img.src = "/static/robot-idle.png";
        img.classList.remove("glow");
        currentSpeaker = null;
      }
      const userImg = document.getElementById('img-0');
      userImg.src = "/static/robot-idle.png";
      userImg.classList.remove("user-speaking");
      window.location.href = "/results";
    }
    function autoScroll() {
      const discussionArea = document.getElementById('discussionArea');
      discussionArea.scrollTop = discussionArea.scrollHeight;
    }
    function addMessage(type, sender, content) {
      const discussionArea = document.getElementById('discussionArea');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}-msg`;
      if (type === 'bot') {
        const botIndex = participants.indexOf(sender);
        if (botIndex > 0) {
          messageDiv.classList.add(`bot-${botIndex}`);
        }
      }
      messageDiv.innerHTML = `
        <div class="sender">${sender}</div>
        <div class="content">${content}</div>
      `;
      discussionArea.appendChild(messageDiv);
    }
    window.speechSynthesis.onvoiceschanged = () => {
      speechSynthesis.getVoices();
    };
  </script>
</body>
</html>